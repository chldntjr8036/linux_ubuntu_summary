# Chapter 19 - 정규 표현식

<hr/>

## 정규 표현식이란? 

* 정규 표현식은 텍스트에서 패턴을 인식하는 심볼 표기법이다. 약간 혼동스러운 점은 모든 정규 표현식이 같지 않다는 것이다.
도구들 마다 다르고 프로그래밍 언어마다 다르다. 여기서는 POSIX 표준의 정규 표현식으로 한정하여 이야기 한다.

<hr/>

## grep - 텍스트를 통한 검색

* grep 이란 ? <b>global regular expression print</b>의 약자. 기본적으로 정규표현식과 일치하는 표준 출력을 가진
행을 출력한다.

* grep \[option\] regex \[file...\]   이런 식으로 옵션과 인자들을 허용한다.

* grep 옵션
    1. -i : 대소문자 무시. --ignore-case로도 지정 가능.
    2. -v : 반전 매치. 정규표현식과 일치하지 않는 패턴 매치
    3. -c : 입치한 행 자체가 아닌 행의 수를 출력
    4. -l : 일치한 행 자체가 아닌 이를 포함한 각각의 파일 이름 출력.
    5. -ㅣ : -l과 유사하지만, 일치하는 행이 없는 파일의 이름만 출력.
    6. -n : 일치하는 행 앞에 파일의 행 번호를 붙인다.
    7. -h : 복수 파일 검색에서, 파일명의 출력을 숨긴다.

* 4~7은 언뜻 이해가 되지 않았는데, file 파라미터를 디렉터리로 착각함. 정규표현식으로 file을 전달할 수 있다.

## 메타문자와 리터럴

* 정규 표현식은 문자 상수(literal characters)이 외에도 메타문자를 포함할 수 있다.

<b> $ . [ ] { } - ? * + ( ) | \ </b>

* 위의 문자들을 쉘에서도 의미를 가지는 메타문자이기 때문에 정규 표현식을 전달할 때 따옴표(')로 감싸는게 필요하다.

***

## 모든 문자 매치 - .

* 도트(.) 문자는 모든 문자에 매치된다.

* 한가지 주의할 점은 .abc 의 경우 "abc"는 찾을 수 없다는 것이다. .는 생략될 수 없으며 최소 네글자의 일치가 필요하기 때문이다.
(혹시나 해서 정리 : " abc"는 매칭이 되긴 하지만 위의 abc는 세글자로 이루어진 abc다.)

***

## 앵커(Anchors) - ^ , $

* 캐럿(^)과 달러 기호($) 문자는 앵커로 처리된다.

* 정규 표현식이 행의 시작(^)이나 행의 끝($)에서 발견되는 경우에만 일치하게 된다는 것을 의미.

* 참고 - ^$는 그 사이에 아무것도 없는 공백줄과 일치한다. 
(echo 공백 | grep ^$ 로 테스트해보면 공백이 뜨는걸 확인할 수 있다.)

***

## 괄호 표현식과 문자 클래스

* 괄포 표현식([])을 사용하여 문자집합의 한 문자와 일치하는지 확인할 수 있다.

* 괄호 안에 놓인 메타문자들은 본래의 특수한 의미를 잃어버린다. 하지만 메타문자는 괄호 표현식에서 다른 의미로 사용되는 경우가 두 가지 있다.

    1. 부정을 나타내는 ^(캐럿)
    2. 범위를 나타내는 -(대시)
    
### 1. 부정

* 괄호 표현식의 첫 번쨰 문자가 캐럿이면, 정규 표현식은 나머지 문자들을 포함한 여집합을 매칭한다.

* 캐럿 문자는 괄호 표현식의 첫 번쨰 문자인 경우에만 부정의 의미를 가진다. 첫 번째가 아니라면 집합의 평범한 문자가 된다.

### 2. 문자 범위

* 대문자의 경우 \[A-Z\], 소문자의 경우 \[a-z\], 숫자의 경우 \[0-9\]로 설정 가능.

* 대시(-)를 문자로 집합에 포함시키위해선 괄호표현식의 첫 문자로 넣는다. \[-AZ\] <- (-,A,Z를 매칭한다.)

***

## POSIX 문자 클래스

### 문자 클래스가 뭐냐? 왜 필요한가?

* 쉽게 말하자면 영문자 아스키 순서(ABCD...Za...z) 와 사전 순서(aAbB...zZ) 사이의 차이로 인해 문자 범위 지정시, 차이가 발생하기 때문이다.
\[A-Z\]에서 아스키 순서는 대문자, 사전 순서에는 사이에 a를 제외한 알파벳 집합이 된다.
이를 해결하기 위해 POSIX는 표준화된 문자 클래스를 제공한다. 

* 자세한 문자 클래스 표는 252p를 보거나 인터넷에 간단하게 검색해도 나온다.
 
***

## POSIX 기본 vs 확장 정규 표현식

* POSIX 정규 표현식을 구현하는 방법은 두가지가 있다.
    1. **기본 정규 표현식(BRD)**
    2. **확장 정규 표현식(ERE)**

* 둘의 차이점은 메타 문자와 관계가 있다. 

* BRE는 ^ $ . \[ \] *, 그 외의 문자들은 리터럴 문자로 인식.
* ERE는 ( ) { } ? + | 가 추가된다.

***

## ERE에 대해 알아보자

***
### | - Alternation
* 표현식 집합 가운데에서 일치하는 것을 찾아주는 기능
```
~ echo "AAA" | egrep 'AAA | BBB | CCC'
AAA
~ echo "BBB" | grep -E 'AAA | BBB | CCC'
BBB
```

* 다른 정규 표현식 요소들을 결합하여 사용하려면 ()로 구분해준다.
```
~ grep -Eh '^(bz|gz|zip)' textfile
textfile에서 bz,gz,zip을 제외한 행이 검색된다.
```
* ()로 분리하지 않으면 ^bz|gz|zip 가 되어 bz가 아닌 문자, gz, zip 을 검색하는 집합이 된다.

***
### 수량 한정자
### ? - 항목이 없거나 한 번만 나타나는 경우
* 타겟 문자 다음에 온다
```
cws@cws-ubuntu:~$ echo "A" | egrep '[A-C]?'
A
cws@cws-ubuntu:~$ echo "B" | egrep '[A-C]?'
B
cws@cws-ubuntu:~$ echo  | egrep '[A-C]?'
(공백이 출력됨)
```
(코드 영역의 빈칸은 공백을 의미함.)
### * - 항목이 없거나 여러 번 나타나는 경우

```
cws@cws-ubuntu:~$ echo "AA" | egrep 'A*'
AA
cws@cws-ubuntu:~$ echo  | egrep 'A*'

cws@cws-ubuntu:~$ echo "AAA" | egrep 'A*'
AAA
```

### + - 항목이 한 번 이상 나타나는 경우
```
cws@cws-ubuntu:~$ echo "AAA" | egrep 'A+'
AAA
cws@cws-ubuntu:~$ echo "" | egrep 'A+'
```

### {} - 항목이 지정된 횟수만큼 나타나는 경우

1. {n} : 정확히 n번만 일치하는 요소 검색
2. {n,m} : 최소 n번, 하지만 m번 미만인 요소 검색
3. {n,} : n번 이상 일치하는 요소 검색
4. {,m} : m번 미만 일치하는 요소 검색

```
cws@cws-ubuntu:~$ echo "AAA" | egrep 'A{3}'
AAA
cws@cws-ubuntu:~$ echo "AAA" | egrep 'A{2}'
AAA
cws@cws-ubuntu:~$ echo "AAA" | egrep 'A{4}'
```



